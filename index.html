<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BentoDB | Your Interactive Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- New Chart.js plugin for data labels -->
    <script src="https://cdn.jsdelivr.net/npm/chartjs-plugin-datalabels@2.0.0"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- New Libraries for Spreadsheet Parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --card-bg: rgba(40, 40, 40, 0.6);
            --border-color: rgba(255, 255, 255, 0.1);
            --text-color: #f0f0f0;
            --text-muted-color: #a0a0a0;
            --accent-color: #3b82f6;
            --glass-blur: 16px;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,0.1) 1px, transparent 0);
            background-size: 20px 20px;
        }
        .glass-card {
            background-color: var(--card-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--border-color);
            transition: all 0.2s ease-in-out;
        }
        .bento-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        /* Custom scrollbar for a better look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.3);
        }
        .resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            right: -4px;
            bottom: -4px;
            cursor: nwse-resize;
            background-image: radial-gradient(circle at 2px 2px, rgba(255,255,255,0.5) 1px, transparent 0);
            background-size: 8px 8px;
            opacity: 0.5;
            transition: opacity 0.2s ease-in-out;
        }
        .bento-item:hover .resize-handle {
            opacity: 1;
        }
        .loading-spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the new filter popover */
        .filter-popover {
            position: absolute;
            z-index: 50;
            top: 100%;
            left: 0;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            transform-origin: top;
            animation: fade-in 0.2s ease-out;
            display: none;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: scale(0.95) translateY(-10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        .filter-popover.active {
            display: block;
        }

        /* Modal backdrop styles */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            backdrop-filter: blur(5px);
            z-index: 40;
            display: none;
            justify-content: center;
            align-items: center;
        }
        .modal-content {
            background-color: var(--bg-color);
            border-radius: 0.75rem;
            padding: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            width: 100%;
            max-width: 500px;
        }
        /* Style for the selected chart type button */
        .chart-type-btn[data-selected="true"] {
            background-color: rgba(59, 130, 246, 0.5);
            border-color: var(--accent-color);
        }
        
        .toast-message {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.1);
            color: var(--text-color);
            padding: 12px 24px;
            border-radius: 9999px;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
            z-index: 100;
        }

        .toast-message.show {
            opacity: 1;
            visibility: visible;
            transition: opacity 0.3s ease;
        }

    </style>
</head>
<body class="min-h-screen">

    <!-- Uploader View -->
    <div id="uploaderView" class="fixed inset-0 flex items-center justify-center p-4 z-50 transition-opacity duration-300">
        <div class="w-full max-w-md text-center">
            <div class="glass-card p-8 rounded-2xl shadow-2xl">
                <h1 class="text-3xl font-bold mb-2">BentoDB</h1>
                <p class="text-md text-gray-400 mb-6">Create beautiful, interactive dashboards from your data files.</p>
                
                <!-- Load Session Button -->
                <button id="loadSessionButton" class="w-full bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors hidden mb-4">
                    Load Previous Session
                </button>
                
                <div id="dropZone" class="border-2 border-dashed border-gray-600 rounded-xl p-8 cursor-pointer hover:border-blue-500 hover:bg-gray-800/20 transition-all">
                    <!-- Updated accept attribute to include spreadsheet files -->
                    <input type="file" id="dbFile" accept=".sqlite,.db,.sqlite3,.csv,.xls,.xlsx" class="hidden">
                    <p class="text-gray-400">Drag & Drop or click to select a file</p>
                </div>
                <div id="loadingIndicator" class="hidden mt-6 flex flex-col items-center">
                    <div class="loading-spinner"></div>
                    <p id="loadingText" class="mt-3 text-gray-400">Loading database...</p>
                </div>
                <p id="error-message" class="text-red-500 mt-4 text-sm hidden"></p>
            </div>
        </div>
    </div>

    <!-- Mapping View (New Step) -->
    <div id="mappingView" class="fixed inset-0 flex items-center justify-center p-4 z-50 transition-opacity duration-300 hidden opacity-0">
        <div class="w-full max-w-4xl max-h-[90vh] flex flex-col glass-card rounded-2xl">
            <div class="p-6 border-b border-[var(--border-color)]">
                <h2 class="text-xl font-bold">Map Your Data</h2>
                <p class="text-gray-400 text-sm mt-1">Review and define column names and data types before creating your dashboard.</p>
            </div>
            <div class="p-6 flex-grow overflow-y-auto space-y-4">
                <!-- New input for table name -->
                <div>
                    <label for="tableNameInput" class="block text-sm font-medium text-gray-300 mb-1">Table Name</label>
                    <input type="text" id="tableNameInput" placeholder="e.g., Sales Data" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none text-sm">
                </div>
                <div id="dataPreview" class="w-full overflow-x-auto rounded-lg border border-gray-700">
                    <!-- Data preview table will be injected here -->
                </div>
                <div id="columnMappingContainer" class="space-y-4">
                    <!-- Column mapping inputs will be injected here -->
                </div>
            </div>
            <div class="p-5 border-t border-[var(--border-color)] flex justify-end items-center gap-4">
                <p id="mappingError" class="text-red-400 text-sm hidden"></p>
                <button id="cancelMappingButton" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">Cancel</button>
                <button id="startDashboardButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">Start Dashboard</button>
            </div>
        </div>
    </div>


    <!-- Dashboard View -->
    <div id="dashboardView" class="hidden opacity-0 transition-opacity duration-500">
        <header class="sticky top-0 z-30 p-4 glass-card m-4 rounded-xl">
            <div class="flex flex-col md:flex-row justify-between items-center gap-4">
                <div class="flex items-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                    <h1 class="text-xl font-bold">Dashboard</h1>
                </div>
                <div id="globalFilters" class="flex flex-wrap gap-2 items-center">
                    <!-- Global filter buttons will be dynamically injected here -->
                    <span id="initialFilterMsg" class="text-sm text-gray-500">Global filters will appear here once you add cards.</span>
                </div>
                <div class="flex items-center gap-2">
                    <button id="saveSessionButton" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>
                        Save
                    </button>
                    <button id="updateDashboardButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 1-9 9 9 9 0 0 1-9-9c0-1.03.17-2.02.48-2.93"/><path d="M12 21V12h9"/><path d="M18.8 8.8c.47-.84.7-1.78.7-2.82A9 9 0 0 0 12 3"/></svg>
                        Update Dashboard
                    </button>
                    <button id="exportPdf" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                        Export PDF
                    </button>
                </div>
            </div>
        </header>

        <main id="dashboardGrid" class="p-4 md:p-8 bento-grid">
            <div id="addQueryCard" class="glass-card rounded-2xl flex items-center justify-center min-h-[200px] cursor-pointer border-2 border-dashed border-gray-600 hover:border-blue-500 hover:bg-gray-800/20 transition-all">
                <div class="text-center">
                    <div class="text-4xl text-gray-500">+</div>
                    <p class="mt-2 font-semibold">Draft Query</p>
                </div>
            </div>
        </main>
    </div>

    <!-- Query Builder Modal -->
    <div id="queryModal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center p-4 z-40 hidden opacity-0 transition-opacity duration-300">
        <div class="glass-card rounded-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
            <div class="p-5 border-b border-[var(--border-color)] flex justify-between items-center">
                <h2 class="text-xl font-bold">Query Builder</h2>
                <button id="closeModal" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="p-6 space-y-5 overflow-y-auto">
                <!-- Table Selection -->
                <div>
                    <label for="tableSelect" class="block text-sm font-medium text-gray-300 mb-1">1. Select Table</label>
                    <select id="tableSelect" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
                </div>
                <!-- Summarize -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">2. Summarize (Aggregate)</label>
                    <div class="grid grid-cols-2 gap-4">
                        <select id="summarizeFunc" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <option value="COUNT">Count</option>
                            <option value="SUM">Sum</option>
                            <option value="AVG">Average</option>
                            <option value="MIN">Minimum</option>
                            <option value="MAX">Maximum</option>
                        </select>
                        <select id="summarizeColumn" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none" disabled>
                            <option>Select Column</option>
                        </select>
                    </div>
                </div>
                <!-- Group By -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">3. By (Group By)</label>
                    <div class="grid grid-cols-2 gap-4">
                        <select id="groupByColumn" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <option>Select Column</option>
                        </select>
                        <select id="groupByDate" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none hidden">
                            <option value="auto">Auto</option>
                            <option value="year">Year</option>
                            <option value="month">Month</option>
                            <option value="week">Week</option>
                            <option value="day">Day</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="p-5 border-t border-[var(--border-color)] flex justify-end items-center gap-4">
                <p id="modal-error" class="text-red-400 text-sm hidden"></p>
                <button id="submitQuery" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">Create Card</button>
            </div>
        </div>
    </div>
    
    <!-- Global Filter Popover -->
    <div id="filterPopover" class="glass-card filter-popover p-4 rounded-xl shadow-lg" tabindex="-1">
      <div class="flex items-center justify-between border-b border-gray-600 pb-2 mb-2">
        <h3 id="popoverTitle" class="font-semibold">Filter Options</h3>
        <button id="closeFilterPopover" class="text-gray-400 hover:text-white">&times;</button>
      </div>
      <div class="flex flex-col gap-2">
        <input id="filterSearch" type="text" placeholder="Search..." class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none">
        <div id="filterOptionsContainer" class="max-h-64 overflow-y-auto space-y-1 pr-2">
          <!-- Checkbox options will be injected here -->
        </div>
      </div>
    </div>

    <!-- Edit/Customize Card Modal -->
    <div id="editCardModal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center p-4 z-40 hidden opacity-0 transition-opacity duration-300">
        <div class="glass-card rounded-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
            <div class="p-5 border-b border-[var(--border-color)] flex justify-between items-center">
                <h2 class="text-xl font-bold">Edit Card</h2>
                <button id="closeEditModal" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="p-6 space-y-5 overflow-y-auto">
                <div>
                    <label for="editTitle" class="block text-sm font-medium text-gray-300 mb-1">Card Title</label>
                    <input type="text" id="editTitle" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                </div>
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">Chart Type</label>
                    <div class="grid grid-cols-4 gap-2">
                        <button id="editTypeBar" data-type="bar" class="chart-type-btn p-2 rounded-lg transition-colors border border-transparent hover:border-blue-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>
                        </button>
                        <button id="editTypeLine" data-type="line" class="chart-type-btn p-2 rounded-lg transition-colors border border-transparent hover:border-blue-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 16 12 14 20 10 4 8 12 2 12"/></svg>
                        </button>
                        <button id="editTypePie" data-type="pie" class="chart-type-btn p-2 rounded-lg transition-colors border border-transparent hover:border-blue-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>
                        </button>
                        <button id="editTypeTable" data-type="table" class="chart-type-btn p-2 rounded-lg transition-colors border border-transparent hover:border-blue-500">
                            <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3zM21 9H3M21 15H3M12 3v18"/></svg>
                        </button>
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="editColor" class="block text-sm font-medium text-gray-300 mb-1">Chart Color</label>
                        <input type="color" id="editColor" class="w-full h-10 border border-gray-600 rounded-lg p-1 cursor-pointer">
                    </div>
                    <div>
                        <label for="editBarThickness" class="block text-sm font-medium text-gray-300 mb-1">Bar/Line Thickness</label>
                        <input type="range" id="editBarThickness" min="1" max="20" value="10" class="w-full h-10 bg-gray-700 rounded-lg appearance-none cursor-pointer focus:outline-none focus:ring-2 focus:ring-blue-500">
                    </div>
                </div>
                <div class="grid grid-cols-2 gap-4">
                    <div class="flex items-center space-x-2">
                        <input type="checkbox" id="editDataLabels" class="w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500">
                        <label for="editDataLabels" class="text-sm font-medium text-gray-300">Show Data Labels</label>
                    </div>
                    <div>
                        <label for="editSortOrder" class="block text-sm font-medium text-gray-300 mb-1">Sort Order</label>
                        <select id="editSortOrder" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <option value="DESC">Descending</option>
                            <option value="ASC">Ascending</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="p-5 border-t border-[var(--border-color)] flex justify-end items-center gap-4">
                <button id="saveEditButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- Confirmation Modal for Delete -->
    <div id="confirmationModal" class="modal-backdrop hidden">
        <div class="modal-content text-center">
            <h3 class="text-xl font-bold mb-4">Confirm Deletion</h3>
            <p class="mb-6">Are you sure you want to delete this card?</p>
            <div class="flex justify-center gap-4">
                <button id="confirmDelete" class="bg-red-600 hover:bg-red-700 text-white font-semibold py-2 px-6 rounded-lg transition-colors">Delete</button>
                <button id="cancelDelete" class="bg-gray-600 hover:bg-gray-700 text-white font-semibold py-2 px-6 rounded-lg transition-colors">Cancel</button>
            </div>
        </div>
    </div>
    
    <!-- Toast Message Container -->
    <div id="toastMessage" class="toast-message"></div>

<script>
    // --- Polyfill for crypto.randomUUID for non-secure contexts ---
    if (typeof crypto === 'undefined' || !crypto.randomUUID) {
        crypto.randomUUID = () => {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)
            );
        };
    }

    // --- DOM Elements ---
    const uploaderView = document.getElementById('uploaderView');
    const mappingView = document.getElementById('mappingView');
    const dashboardView = document.getElementById('dashboardView');
    const dbFileInput = document.getElementById('dbFile');
    const dropZone = document.getElementById('dropZone');
    const browseButton = document.getElementById('browseButton');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const loadingText = document.getElementById('loadingText');
    const errorMessage = document.getElementById('error-message');
    const fileNameSpan = document.getElementById('fileNameSpan');
    const tableNameInput = document.getElementById('tableNameInput');
    const dataPreview = document.getElementById('dataPreview');
    const columnMappingContainer = document.getElementById('columnMappingContainer');
    const cancelMappingButton = document.getElementById('cancelMappingButton');
    const startDashboardButton = document.getElementById('startDashboardButton');
    const mappingError = document.getElementById('mappingError');
    const addQueryCard = document.getElementById('addQueryCard');
    const queryModal = document.getElementById('queryModal');
    const closeModal = document.getElementById('closeModal');
    const tableSelect = document.getElementById('tableSelect');
    const summarizeFunc = document.getElementById('summarizeFunc');
    const summarizeColumn = document.getElementById('summarizeColumn');
    const groupByColumn = document.getElementById('groupByColumn');
    const groupByDate = document.getElementById('groupByDate');
    const submitQuery = document.getElementById('submitQuery');
    const dashboardGrid = document.getElementById('dashboardGrid');
    const globalFiltersContainer = document.getElementById('globalFilters');
    const exportPdfButton = document.getElementById('exportPdf');
    const updateDashboardButton = document.getElementById('updateDashboardButton');
    const modalError = document.getElementById('modal-error');
    const filterPopover = document.getElementById('filterPopover');
    const popoverTitle = document.getElementById('popoverTitle');
    const closeFilterPopover = document.getElementById('closeFilterPopover');
    const filterSearch = document.getElementById('filterSearch');
    const filterOptionsContainer = document.getElementById('filterOptionsContainer');
    const editCardModal = document.getElementById('editCardModal');
    const closeEditModal = document.getElementById('closeEditModal');
    const editTitleInput = document.getElementById('editTitle');
    const chartTypeButtons = document.querySelectorAll('.chart-type-btn');
    const editColorInput = document.getElementById('editColor');
    const editBarThicknessInput = document.getElementById('editBarThickness');
    const editDataLabelsCheckbox = document.getElementById('editDataLabels');
    const editSortOrderSelect = document.getElementById('editSortOrder');
    const saveEditButton = document.getElementById('saveEditButton');
    const confirmationModal = document.getElementById('confirmationModal');
    const confirmDeleteButton = document.getElementById('confirmDelete');
    const cancelDeleteButton = document.getElementById('cancelDelete');
    const saveSessionButton = document.getElementById('saveSessionButton');
    const loadSessionButton = document.getElementById('loadSessionButton');
    const toastMessage = document.getElementById('toastMessage');


    // --- App State ---
    let db;
    let dbSchema = {};
    let dashboardCards = [];
    let charts = {}; // To store chart instances
    let globalFilters = {}; // Key: columnName, Value: Array of selected values
    let currentEditCardId = null; // Track which card is being edited
    let currentSpreadsheetData = null; // Store the raw spreadsheet data and header for mapping
    let currentFileName = null; // Store the file name for display

    // --- SQL.js Initialization ---
    async function initializeSqlJs() {
        try {
            const SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
            });
            return SQL;
        } catch (err) {
            console.error(err);
            showError("Failed to load SQL.js library. Please check your internet connection.");
        }
    }

    let sqlJsPromise = initializeSqlJs();

    // --- Utility Functions for Base64 Conversion ---
    function uint8ToBase64(uint8) {
        let binary = '';
        for (let i = 0; i < uint8.length; i++) {
            binary += String.fromCharCode(uint8[i]);
        }
        return btoa(binary);
    }

    function base64ToUint8(base64) {
        const binary = atob(base64);
        const uint8 = new Uint8Array(binary.length);
        for (let i = 0; i < binary.length; i++) {
            uint8[i] = binary.charCodeAt(i);
        }
        return uint8;
    }

    // --- Persistence Functions ---
    function showToast(message) {
        toastMessage.textContent = message;
        toastMessage.classList.add('show');
        setTimeout(() => {
            toastMessage.classList.remove('show');
        }, 3000);
    }

    function saveSession() {
        try {
            if (!db) {
                showToast("No database to save!");
                return;
            }
            // Export the database
            const binaryArray = db.export();
            const dbBase64 = uint8ToBase64(binaryArray);

            // Save the dashboard cards and db to localStorage
            localStorage.setItem('bentoDbState', JSON.stringify(dashboardCards));
            localStorage.setItem('bentoDbDb', dbBase64);
            localStorage.setItem('bentoDbSchema', JSON.stringify(dbSchema));
            
            showToast("Session saved successfully!");
        } catch (e) {
            console.error("Save failed:", e);
            showToast(`Save failed: ${e.message}. The database might be too large.`);
        }
    }
    
    async function loadSession() {
        try {
            const savedDbBase64 = localStorage.getItem('bentoDbDb');
            const savedState = localStorage.getItem('bentoDbState');
            const savedSchema = localStorage.getItem('bentoDbSchema');

            if (!savedDbBase64 || !savedState) {
                showToast("No saved session found.");
                return;
            }

            loadingText.textContent = "Loading saved session...";
            loadingIndicator.classList.remove('hidden');
            uploaderView.classList.add('hidden', 'opacity-0');

            const SQL = await sqlJsPromise;
            const dbBinary = base64ToUint8(savedDbBase64);
            db = new SQL.Database(dbBinary);

            dashboardCards = JSON.parse(savedState);
            dbSchema = JSON.parse(savedSchema);
            
            // Re-render the dashboard with the loaded data
            renderDashboard();

            dashboardView.classList.remove('hidden');
            setTimeout(() => dashboardView.classList.remove('opacity-0'), 50);
            loadingIndicator.classList.add('hidden');
            showToast("Session loaded successfully!");

        } catch (e) {
            console.error("Load failed:", e);
            showToast(`Failed to load session: ${e.message}`);
            uploaderView.classList.remove('hidden', 'opacity-0');
        }
    }

    // --- Initial Load Check ---
    window.onload = function() {
        if (localStorage.getItem('bentoDbState') && localStorage.getItem('bentoDbDb')) {
            loadSessionButton.classList.remove('hidden');
        }
    }


    // --- Event Listeners ---
    dropZone.addEventListener('click', () => dbFileInput.click());
    dbFileInput.addEventListener('change', handleFileSelect);
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('border-blue-500', 'bg-gray-800/20');
    });
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('border-blue-500', 'bg-gray-800/20');
    });
    dropZone.addEventListener('drop', handleFileDrop);
    addQueryCard.addEventListener('click', openQueryModal);
    closeModal.addEventListener('click', closeQueryModal);
    queryModal.addEventListener('click', (e) => {
        if (e.target === queryModal) closeQueryModal();
    });

    tableSelect.addEventListener('change', onTableSelectChange);
    summarizeFunc.addEventListener('change', onSummarizeFuncChange);
    groupByColumn.addEventListener('change', onGroupByColumnChange);
    submitQuery.addEventListener('click', handleQuerySubmit);
    exportPdfButton.addEventListener('click', handleExport);
    updateDashboardButton.addEventListener('click', renderDashboard);
    cancelMappingButton.addEventListener('click', () => {
        mappingView.classList.add('opacity-0');
        setTimeout(() => uploaderView.classList.remove('hidden', 'opacity-0'), 300);
    });
    startDashboardButton.addEventListener('click', handleMappingConfirm);

    // New event listeners for save/load
    saveSessionButton.addEventListener('click', saveSession);
    loadSessionButton.addEventListener('click', loadSession);

    // Filter popover listeners
    closeFilterPopover.addEventListener('click', closeFilterPopoverFunc);
    filterSearch.addEventListener('input', (e) => updateFilterOptions(e.target.dataset.column, e.target.value));

    // Close popover when clicking outside
    document.addEventListener('click', (e) => {
        if (filterPopover.classList.contains('active') && !filterPopover.contains(e.target) && !e.target.closest('.filter-button')) {
            closeFilterPopoverFunc();
        }
    });

    // Edit modal listeners
    closeEditModal.addEventListener('click', () => editCardModal.classList.add('hidden', 'opacity-0'));
    editCardModal.addEventListener('click', (e) => {
        if (e.target === editCardModal) editCardModal.classList.add('hidden', 'opacity-0');
    });
    chartTypeButtons.forEach(btn => btn.addEventListener('click', onChartTypeButtonClick));
    saveEditButton.addEventListener('click', handleEditSubmit);
    
    // Confirmation modal listeners
    cancelDeleteButton.addEventListener('click', () => confirmationModal.classList.add('hidden'));
    confirmDeleteButton.addEventListener('click', () => {
        deleteCard(confirmDeleteButton.dataset.cardId);
        confirmationModal.classList.add('hidden');
    });

    // --- File Handling ---
    function handleFileDrop(e) {
        e.preventDefault();
        dropZone.classList.remove('border-blue-500', 'bg-gray-800/20');
        const files = e.dataTransfer.files;
        if (files.length) {
            dbFileInput.files = files;
            handleFileSelect({ target: { files } });
        }
    }

    async function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        loadingIndicator.classList.remove('hidden');
        dropZone.classList.add('hidden');
        errorMessage.classList.add('hidden');
        loadSessionButton.classList.add('hidden');
        
        const fileExtension = file.name.split('.').pop().toLowerCase();
        currentFileName = file.name;
        
        try {
            loadingText.textContent = "Reading file...";
            const fileBuffer = await file.arrayBuffer();

            const SQL = await sqlJsPromise;
            db = new SQL.Database(); // Create a new in-memory DB
            
            if (['sqlite', 'db', 'sqlite3'].includes(fileExtension)) {
                loadingText.textContent = "Loading database...";
                db = new SQL.Database(new Uint8Array(fileBuffer));
                await inspectDatabase();
                
                // Transition directly to dashboard for SQLite files
                uploaderView.classList.add('opacity-0');
                setTimeout(() => {
                    uploaderView.classList.add('hidden');
                    dashboardView.classList.remove('hidden');
                    setTimeout(() => dashboardView.classList.remove('opacity-0'), 50);
                }, 300);

            } else if (['csv', 'xls', 'xlsx'].includes(fileExtension)) {
                loadingText.textContent = "Parsing spreadsheet...";
                const { data, header } = await loadSpreadsheet(file, fileBuffer);
                currentSpreadsheetData = { data, header, originalFileName: file.name };
                showMappingView();
                
            } else {
                throw new Error("Unsupported file type.");
            }
        } catch (err) {
            console.error("File loading error:", err);
            showError(`Could not read the file: ${err.message}.`);
            loadingIndicator.classList.add('hidden');
            dropZone.classList.remove('hidden');
            if (localStorage.getItem('bentoDbState') && localStorage.getItem('bentoDbDb')) {
                loadSessionButton.classList.remove('hidden');
            }
        }
    }
    
    // Function to parse spreadsheet data and load it into SQLite
    async function loadSpreadsheet(file, buffer) {
        const fileExtension = file.name.split('.').pop().toLowerCase();
        let data = [];
        let tableHeader = [];
        
        if (fileExtension === 'csv') {
            const results = await new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: resolve,
                    error: reject
                });
            });
            data = results.data;
            if (data.length > 0) {
                tableHeader = Object.keys(data[0]);
            }
        } else if (['xls', 'xlsx'].includes(fileExtension)) {
            const workbook = XLSX.read(buffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
            if (data.length > 0) {
                tableHeader = data[0];
                data = data.slice(1);
            }
        } else {
            throw new Error("Unsupported file type.");
        }

        if (data.length === 0) {
            throw new Error("The file is empty or could not be parsed.");
        }
        
        return { data, header: tableHeader };
    }
    
    // Updated sanitization logic for file names
    function sanitizeTableName(name) {
        // Remove file extension
        const baseName = name.split('.').slice(0, -1).join('.');
        // Replace invalid characters with underscore
        let sanitized = baseName.replace(/[^a-zA-Z0-9_]/g, '_');
        // Ensure it doesn't start with a number, which can cause SQL errors
        if (sanitized.match(/^\d/)) {
            sanitized = 't_' + sanitized;
        }
        return sanitized;
    }

    // Updated sanitization logic for column names
    function sanitizeColumnName(name) {
        // Replace invalid characters with underscore
        let sanitized = name.replace(/[^a-zA-Z0-9_]/g, '_');
        // Replace multiple underscores with a single one
        sanitized = sanitized.replace(/_+/g, '_');
        // Ensure it doesn't start with a number
        if (sanitized.match(/^\d/)) {
            sanitized = 'col_' + sanitized;
        }
        return sanitized.toLowerCase();
    }
    
    function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.remove('hidden');
    }
    
    // --- Mapping View Logic ---
    function showMappingView() {
        uploaderView.classList.add('hidden', 'opacity-0');
        mappingView.classList.remove('hidden');
        setTimeout(() => mappingView.classList.remove('opacity-0'), 10);
        
        // Set default table name
        const defaultTableName = currentFileName.split('.').slice(0, -1).join('.');
        tableNameInput.value = defaultTableName;

        const { header, data } = currentSpreadsheetData;
        
        // Populate data preview table
        let previewHTML = '<table class="w-full text-sm text-left table-auto"><thead><tr class="border-b border-gray-700">';
        header.forEach(h => previewHTML += `<th class="p-2 whitespace-nowrap">${h}</th>`);
        previewHTML += '</tr></thead><tbody>';
        data.slice(0, 10).forEach(row => {
            previewHTML += '<tr class="border-b border-gray-800">';
            const values = Array.isArray(row) ? row : header.map(h => row[h]);
            values.forEach(cell => previewHTML += `<td class="p-2 whitespace-nowrap">${cell === null ? 'NULL' : cell}</td>`);
            previewHTML += '</tr>';
        });
        previewHTML += '</tbody></table>';
        dataPreview.innerHTML = previewHTML;
        
        // Populate column mapping inputs
        columnMappingContainer.innerHTML = '';
        header.forEach((originalName) => {
            const container = document.createElement('div');
            container.className = 'flex flex-col md:flex-row items-center gap-2 p-3 rounded-lg border border-gray-700';
            
            // Original Name
            const originalNameDiv = document.createElement('div');
            originalNameDiv.className = 'flex-1 text-sm text-gray-400 truncate';
            originalNameDiv.textContent = originalName;
            
            // New Name Input
            const nameInput = document.createElement('input');
            nameInput.type = 'text';
            nameInput.value = sanitizeColumnName(originalName);
            nameInput.dataset.originalName = originalName;
            nameInput.placeholder = 'New Column Name';
            nameInput.className = 'flex-1 w-full md:w-auto bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none text-sm';
            
            // Type Select
            const typeSelect = document.createElement('select');
            typeSelect.className = 'w-full md:w-auto bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none text-sm';
            const guessedType = guessDataType(originalName, data);
            
            const types = ['STRING', 'INTEGER', 'REAL', 'DATE', 'DATETIME'];
            types.forEach(type => {
                const option = document.createElement('option');
                option.value = type;
                option.textContent = type;
                if (type === guessedType) {
                    option.selected = true;
                }
                typeSelect.appendChild(option);
            });
            
            // Filter Checkbox
            const filterCheckboxContainer = document.createElement('div');
            filterCheckboxContainer.className = 'flex items-center space-x-2';
            const filterCheckbox = document.createElement('input');
            filterCheckbox.type = 'checkbox';
            filterCheckbox.checked = true; // Default to true
            filterCheckbox.className = 'w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500';
            filterCheckbox.id = `filter-${sanitizeColumnName(originalName)}`;
            const filterLabel = document.createElement('label');
            filterLabel.htmlFor = `filter-${sanitizeColumnName(originalName)}`;
            filterLabel.textContent = "Include in global filters?";
            filterLabel.className = 'text-sm font-medium text-gray-300 whitespace-nowrap';
            filterCheckboxContainer.append(filterCheckbox, filterLabel);

            container.append(originalNameDiv, nameInput, typeSelect, filterCheckboxContainer);
            columnMappingContainer.appendChild(container);
        });
    }

    function guessDataType(columnName, data) {
        let isNumber = true;
        let isDate = true;
        
        for (let i = 0; i < Math.min(data.length, 50); i++) {
            const value = data[i][columnName] || data[i][Object.keys(data[0]).indexOf(columnName)];
            
            if (value === null || value === '') continue;
            
            // Check for number
            if (isNumber && (isNaN(parseFloat(value)) || !isFinite(value))) {
                isNumber = false;
            }
            
            // Check for date (basic check)
            if (isDate && isNaN(new Date(value).getTime())) {
                isDate = false;
            }
        }
        
        if (isNumber) return 'REAL';
        if (isDate) return 'DATETIME';
        return 'STRING';
    }
    
    async function handleMappingConfirm() {
        const tableDisplayName = tableNameInput.value || currentFileName.split('.').slice(0, -1).join('.');
        const tableName = sanitizeTableName(currentFileName);
        const newColumns = [];
        const oldToNewMap = {};

        const mappingInputs = columnMappingContainer.querySelectorAll('input[type="text"]');
        const mappingSelects = columnMappingContainer.querySelectorAll('select');
        const filterCheckboxes = columnMappingContainer.querySelectorAll('input[type="checkbox"]');
        
        // Validate and gather user-defined schema
        mappingInputs.forEach((input, index) => {
            const originalName = input.dataset.originalName;
            const newName = sanitizeColumnName(input.value);
            const newType = mappingSelects[index].value;
            const isFilterable = filterCheckboxes[index].checked;

            if (!newName) {
                mappingError.textContent = 'Column names cannot be empty.';
                mappingError.classList.remove('hidden');
                setTimeout(() => mappingError.classList.add('hidden'), 3000);
                return;
            }
            
            newColumns.push({ originalName, newName, newType, isFilterable });
            oldToNewMap[originalName] = newName;
        });
        
        if (mappingError.classList.contains('hidden') === false) return; // Exit if validation failed

        // Recreate the in-memory database with the new schema
        db.close();
        const SQL = await sqlJsPromise;
        db = new SQL.Database();
        
        const columnDefinitions = newColumns.map(col => `"${col.newName}" ${col.newType}`).join(', ');
        db.exec(`CREATE TABLE IF NOT EXISTS "${tableName}" (${columnDefinitions});`);

        const placeholders = newColumns.map(() => '?').join(', ');
        const insertStmt = db.prepare(`INSERT INTO "${tableName}" VALUES (${placeholders});`);

        db.run('BEGIN TRANSACTION;');
        try {
            currentSpreadsheetData.data.forEach(row => {
                const values = newColumns.map(col => {
                    const originalValue = row[col.originalName] !== undefined ? row[col.originalName] : row[Object.keys(row).indexOf(col.originalName)];
                    if (originalValue === null || originalValue === undefined) return null;
                    if (col.newType === 'INTEGER' || col.newType === 'REAL') {
                        const parsed = parseFloat(originalValue);
                        return isNaN(parsed) ? null : parsed;
                    }
                    return String(originalValue);
                });
                insertStmt.run(values);
            });
            db.run('COMMIT;');
        } catch (e) {
            db.run('ROLLBACK;');
            showError(`Failed to insert data with new schema: ${e.message}`);
            return;
        } finally {
            insertStmt.free();
        }
        
        // Populate dbSchema manually after mapping
        dbSchema = {};
        dbSchema.tables = [tableName];
        dbSchema[tableName] = { 
            displayName: tableDisplayName,
            columns: newColumns.map(col => ({
                name: col.newName,
                type: col.newType.toUpperCase(),
                isFilterable: col.isFilterable
            }))
        };
        
        populateTableSelect(); // Update the query builder table dropdown
        
        // Transition to dashboard
        mappingView.classList.add('opacity-0');
        setTimeout(() => {
            mappingView.classList.add('hidden');
            dashboardView.classList.remove('hidden');
            setTimeout(() => dashboardView.classList.remove('opacity-0'), 50);
        }, 300);
    }
    
    // --- Database Schema Inspection ---
    async function inspectDatabase() {
        const tablesResult = db.exec("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';");
        if (!tablesResult.length) return;

        const tableNames = tablesResult[0].values.map(v => v[0]);
        dbSchema.tables = tableNames;

        for (const tableName of tableNames) {
            const columnsResult = db.exec(`PRAGMA table_info("${tableName}");`);
            const columns = columnsResult[0].values.map(col => ({
                name: col[1],
                type: col[2].toUpperCase(),
                isFilterable: true,
            }));
            
            dbSchema[tableName] = { 
                displayName: tableName,
                columns: columns 
            };
        }
        populateTableSelect();
    }
    
    // --- Query Modal Logic ---
    function populateTableSelect() {
        tableSelect.innerHTML = '<option disabled selected>Select a table</option>';
        dbSchema.tables.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = dbSchema[name].displayName || name;
            tableSelect.appendChild(option);
        });
    }
    
    function populateSummarizeColumn(tableName) {
        const { columns } = dbSchema[tableName];
        // Now use the inferredType to filter for numeric columns
        const numericColumns = columns.filter(c => ['NUMERIC', 'INTEGER', 'REAL'].includes(c.type));

        summarizeColumn.innerHTML = '<option disabled selected>Select Column</option>';
        if (summarizeFunc.value !== 'COUNT') {
            numericColumns.forEach(col => {
                const option = document.createElement('option');
                option.value = col.name;
                option.textContent = col.name;
                summarizeColumn.appendChild(option);
            });
        }
    }

    function onTableSelectChange() {
        const tableName = tableSelect.value;
        if (!tableName || !dbSchema[tableName]) return;

        const { columns } = dbSchema[tableName];
        
        populateSummarizeColumn(tableName);
        
        groupByColumn.innerHTML = '<option disabled selected>Select Column</option>';
        columns.forEach(col => {
            const option = document.createElement('option');
            option.value = col.name;
            // Use the original type from pragma for date checks
            option.dataset.type = col.type; 
            option.textContent = col.name;
            groupByColumn.appendChild(option);
        });
        
        onSummarizeFuncChange();
        onGroupByColumnChange();
    }
    
    function onSummarizeFuncChange() {
        const isCount = summarizeFunc.value === 'COUNT';
        summarizeColumn.disabled = isCount;
        
        const tableName = tableSelect.value;
        // Added a check to alert the user to select a table first
        if (!isCount && (!tableName || tableName.includes('Select'))) {
            modalError.textContent = 'Please select a table first to see numeric columns.';
            modalError.classList.remove('hidden');
            setTimeout(() => modalError.classList.add('hidden'), 3000);
            return;
        }

        if (isCount) {
            summarizeColumn.innerHTML = '<option>Not Applicable</option>';
        } else {
            const tableName = tableSelect.value;
            if (tableName && dbSchema[tableName]) {
                populateSummarizeColumn(tableName);
            }
        }
    }

    function onGroupByColumnChange() {
        const selectedOption = groupByColumn.options[groupByColumn.selectedIndex];
        if (!selectedOption) {
             groupByDate.classList.add('hidden');
             return;
        }
        const type = selectedOption.dataset.type;
        const isDateType = ['DATE', 'DATETIME'].includes(type);
        groupByDate.classList.toggle('hidden', !isDateType);
    }
    
    function openQueryModal() {
        queryModal.classList.remove('hidden');
        setTimeout(() => queryModal.classList.remove('opacity-0'), 10);
    }

    function closeQueryModal() {
        queryModal.classList.add('opacity-0');
        setTimeout(() => {
            queryModal.classList.add('hidden');
            modalError.classList.add('hidden'); // Hide error on close
        }, 300);
    }

    // --- Query Execution & Card Creation ---
    async function handleQuerySubmit() {
        const table = tableSelect.value;
        const aggFunc = summarizeFunc.value;
        const aggColumn = summarizeColumn.value;
        const groupBy = groupByColumn.value;

        if (!table || table.includes('Select') ||
            !groupBy || groupBy.includes('Select') ||
            (aggFunc !== 'COUNT' && (!aggColumn || aggColumn.includes('Select'))))
        {
            modalError.textContent = 'Please fill out all fields correctly.';
            modalError.classList.remove('hidden');
            setTimeout(() => modalError.classList.add('hidden'), 3000);
            return;
        }

        const queryConfig = {
            id: crypto.randomUUID(),
            table: table,
            aggFunc: aggFunc,
            aggColumn: aggFunc === 'COUNT' ? '*' : aggColumn,
            groupBy: groupBy,
            groupByDateUnit: groupByDate.value,
            chartType: 'bar',
            custom: {
                title: `${aggFunc} of ${aggColumn || 'Rows'} by ${groupBy}`,
                color: '#3b82f6',
                dataLabels: false,
                thickness: 10,
                sortOrder: 'DESC'
            },
            size: { width: 'auto', height: '400px' }
        };

        dashboardCards.push(queryConfig);
        renderDashboard();
        closeQueryModal();
    }

    function buildQuery(config, filters = {}) {
        let selectClause = '';
        let groupByClause = `GROUP BY T1."${config.groupBy}"`;
        let whereClauses = [];

        // Correctly handle COUNT(*) and other aggregates
        const aggColumnSelect = config.aggColumn === '*' ? '*' : `T1."${config.aggColumn}"`;

        const tableSchema = dbSchema[config.table];
        if (!tableSchema) return ''; // Should not happen
        const groupByColumnSchema = tableSchema.columns.find(c => c.name === config.groupBy);
        const groupByColType = groupByColumnSchema ? groupByColumnSchema.type : '';
        const isDateType = ['DATE', 'DATETIME', 'TIMESTAMP'].includes(groupByColType);

        if (isDateType && config.groupByDateUnit && config.groupByDateUnit !== 'auto') {
             let format;
             switch(config.groupByDateUnit) {
                 case 'year': format = '%Y'; break;
                 case 'month': format = '%Y-%m'; break;
                 case 'week': format = '%Y-%W'; break;
                 case 'day': format = '%Y-%m-%d'; break;
             }
             if (format) {
                 selectClause = `strftime('${format}', T1."${config.groupBy}") as "${config.groupBy}", ${config.aggFunc}(${aggColumnSelect}) as value`;
                 groupByClause = `GROUP BY 1`; // Group by the first column
             }
        }
        
        if (!selectClause) {
            selectClause = `T1."${config.groupBy}", ${config.aggFunc}(${aggColumnSelect}) as value`;
        }

        // Apply global filters
        for(const [key, values] of Object.entries(filters)) {
            if(values && values.length > 0) {
                const quotedValues = values.map(v => `'${String(v).replace(/'/g, "''")}'`).join(',');
                whereClauses.push(`T1."${key}" IN (${quotedValues})`);
            }
        }
        let whereClause = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';
        const orderByClause = `ORDER BY 2 ${config.custom.sortOrder || 'DESC'} LIMIT 50`;

        return `SELECT ${selectClause} FROM "${config.table}" AS T1 ${whereClause} ${groupByClause} ${orderByClause};`;
    }

    function runQuery(sql) {
        try {
            const results = db.exec(sql);
            if (results.length > 0) {
                return results[0]; // Returns {columns: [...], values: [...]}
            }
            return { columns: [], values: [] };
        } catch(e) {
            console.error("Query failed:", sql, e);
            return { error: e.message };
        }
    }

    // --- Dashboard Rendering ---
    function renderDashboard() {
        dashboardGrid.innerHTML = '';
        dashboardGrid.appendChild(addQueryCard);
        dashboardCards.forEach(cardConfig => createCard(cardConfig));
        updateGlobalFilters();
    }
    
    function createCard(config) {
        const cardEl = document.createElement('div');
        cardEl.className = 'bento-item glass-card rounded-2xl p-4 flex flex-col relative';
        cardEl.id = `card-${config.id}`;
        cardEl.style.height = config.size.height;
        // Handle responsive resizing properly
        if (config.size.width && config.size.width !== 'auto') {
            cardEl.style.width = config.size.width;
            if(parseInt(config.size.width, 10) > dashboardGrid.clientWidth * 0.9) {
                 cardEl.style.gridColumn = '1 / -1';
            }
        }

        const sql = buildQuery(config, globalFilters);
        const result = runQuery(sql);

        // Header
        const header = document.createElement('div');
        header.className = 'flex justify-between items-start mb-2';
        const title = document.createElement('h3');
        title.className = 'font-semibold text-base pr-2';
        title.textContent = config.custom.title;
        header.appendChild(title);

        // Card controls
        const controls = document.createElement('div');
        controls.className = 'flex gap-1 items-center';
        
        // Edit button
        const editBtn = document.createElement('button');
        editBtn.className = 'p-1 rounded hover:bg-gray-700';
        editBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.828 2.828 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"/></svg>`;
        editBtn.onclick = () => openEditModal(config.id);
        controls.appendChild(editBtn);

        // Delete button
        const deleteBtn = document.createElement('button');
        deleteBtn.className = 'p-1 rounded hover:bg-gray-700';
        deleteBtn.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"/><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"/><line x1="10" y1="11" x2="10" y2="17"/><line x1="14" y1="11" x2="14" y2="17"/></svg>`;
        deleteBtn.onclick = () => showConfirmationModal(config.id);
        controls.appendChild(deleteBtn);

        header.appendChild(controls);

        // Chart/Table container
        const contentContainer = document.createElement('div');
        contentContainer.className = 'flex-grow relative';

        if(result.error){
            contentContainer.innerHTML = `<div class="text-red-400 text-sm p-4">Error: ${result.error}</div>`
        } else if (config.chartType === 'table') {
            contentContainer.innerHTML = createTableHTML(result);
        } else {
            const canvas = document.createElement('canvas');
            contentContainer.appendChild(canvas);
            setTimeout(() => createChart(canvas, config, result.values), 0); // Render chart after element is in DOM
        }
        
        // Resize handle
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        
        cardEl.append(header, contentContainer, resizeHandle);
        dashboardGrid.insertBefore(cardEl, addQueryCard);

        makeResizable(cardEl, config);
    }
    
    function createChart(canvas, config, data) {
        const labels = data.map(row => row[0]);
        const values = data.map(row => row[1]);

        if (charts[config.id]) {
            charts[config.id].destroy();
        }

        const datasets = [{
            label: config.aggFunc,
            data: values,
            backgroundColor: config.chartType === 'pie' ? generateColors(values.length) : config.custom.color,
            borderColor: config.custom.color,
            borderWidth: config.custom.thickness,
            tension: 0.1,
            barThickness: config.custom.thickness,
        }];

        const plugins = [ChartDataLabels];
        const options = {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: {
                    display: config.chartType === 'pie',
                    labels: { color: 'white' }
                },
                datalabels: {
                    display: config.custom.dataLabels,
                    color: 'white',
                    anchor: 'end',
                    align: 'top'
                }
            },
            scales: {
                x: { display: config.chartType !== 'pie', ticks: { color: 'white', autoSkip: true, maxTicksLimit: 10 } },
                y: { display: config.chartType !== 'pie', ticks: { color: 'white' } }
            }
        };

        if (config.chartType === 'pie') {
            options.plugins.datalabels.align = 'center';
            options.plugins.datalabels.formatter = (value, context) => {
                const total = context.chart.data.datasets[0].data.reduce((acc, curr) => acc + curr, 0);
                const percentage = Math.round((value / total) * 100);
                return `${percentage}%`;
            };
        } else {
            options.plugins.datalabels.formatter = (value) => value.toLocaleString();
        }

        charts[config.id] = new Chart(canvas, {
            type: config.chartType,
            data: { labels, datasets },
            options,
            plugins
        });
    }

    function createTableHTML(result) {
        const { columns, values } = result;
        if (!values || values.length === 0) return '<p class="text-gray-500 text-center p-4">No data to display.</p>';

        let tableHTML = '<div class="overflow-auto h-full"><table class="w-full text-sm text-left"><thead><tr class="border-b border-gray-700">';
        columns.forEach(h => tableHTML += `<th class="p-2">${h}</th>`);
        tableHTML += '</tr></thead><tbody>';
        values.forEach(row => {
            tableHTML += '<tr class="border-b border-gray-800">';
            row.forEach(cell => tableHTML += `<td class="p-2">${cell === null ? 'NULL' : cell}</td>`);
            tableHTML += '</tr>';
        });
        tableHTML += '</tbody></table></div>';
        return tableHTML;
    }

    // --- Global Filters ---
    function updateGlobalFilters() {
        const activeColumns = new Map();
        dashboardCards.forEach(card => {
            const tableSchema = dbSchema[card.table];
            if (tableSchema) {
                tableSchema.columns.forEach(col => {
                    // Only include columns marked as filterable
                    if(col.isFilterable && !activeColumns.has(col.name)) {
                         activeColumns.set(col.name, col);
                    }
                });
            }
        });

        const initialFilterMsg = document.getElementById('initialFilterMsg');
        if (initialFilterMsg) {
            initialFilterMsg.classList.toggle('hidden', activeColumns.size > 0);
        }
        globalFiltersContainer.innerHTML = '';
        activeColumns.forEach((col, colName) => {
            const btn = document.createElement('button');
            btn.className = `filter-button relative bg-gray-900/50 hover:bg-gray-800/50 text-white font-semibold py-2 px-4 rounded-lg transition-colors text-sm`;
            btn.textContent = colName;
            btn.dataset.column = colName;
            btn.dataset.type = col.type; // Pass the column type to the button

            // Add a counter to the button if filters are active
            if (globalFilters[colName] && globalFilters[colName].length > 0) {
                const countSpan = document.createElement('span');
                countSpan.className = 'ml-2 text-xs font-bold text-white bg-blue-600 rounded-full px-2 py-1';
                countSpan.textContent = globalFilters[colName].length;
                btn.appendChild(countSpan);
            }

            btn.addEventListener('click', (e) => openFilterPopover(e, colName));
            globalFiltersContainer.appendChild(btn);
        });
    }

    function openFilterPopover(e, columnName) {
        const rect = e.target.getBoundingClientRect();
        filterPopover.style.top = `${rect.bottom + window.scrollY + 8}px`;
        filterPopover.style.left = `${rect.left + window.scrollX}px`;
        popoverTitle.textContent = `Filter by ${columnName}`;
        filterSearch.dataset.column = columnName;
        filterSearch.value = '';
        filterPopover.classList.add('active');
        populateFilterOptions(columnName);
    }
    
    function closeFilterPopoverFunc() {
        filterPopover.classList.remove('active');
    }

    function getDisplayValue(value, type) {
        if (value === null) return "NULL";
        if (['DATE', 'DATETIME'].includes(type) && typeof value === 'string') {
            try {
                const date = new Date(value);
                return date.toISOString().split('T')[0]; // Simple YYYY-MM-DD format
            } catch(e) {
                return value; // Fallback
            }
        }
        return value;
    }

    function populateFilterOptions(columnName, searchText = '') {
        filterOptionsContainer.innerHTML = '<p class="text-center text-gray-500">Loading...</p>';
        const tableNameForFilter = dbSchema.tables.find(t => dbSchema[t].columns.some(c => c.name === columnName));
        if (!tableNameForFilter) {
            filterOptionsContainer.innerHTML = '<p class="text-center text-gray-500">No data found.</p>';
            return;
        }
        const columnType = dbSchema[tableNameForFilter].columns.find(c => c.name === columnName).type;

        const distinctValuesQuery = `SELECT DISTINCT "${columnName}" FROM "${tableNameForFilter}" WHERE "${columnName}" IS NOT NULL ORDER BY "${columnName}" ASC LIMIT 1000;`;
        const results = runQuery(distinctValuesQuery);
        
        filterOptionsContainer.innerHTML = '';
        const selectedValues = globalFilters[columnName] || [];
        
        if (results && Array.isArray(results.values)) {
            const filteredValues = results.values.filter(row => 
                String(row[0]).toLowerCase().includes(searchText.toLowerCase())
            );

            filteredValues.forEach(row => {
                const value = row[0];
                const displayValue = getDisplayValue(value, columnType);
                const checkboxId = `${columnName}-${String(value).replace(/[^a-zA-Z0-9_]/g, '_')}`;
                
                const div = document.createElement('div');
                div.className = 'flex items-center space-x-2';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = checkboxId;
                input.value = String(value);
                input.checked = selectedValues.includes(String(value));
                input.className = 'w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500';
                input.addEventListener('change', (e) => {
                    if (!globalFilters[columnName]) {
                        globalFilters[columnName] = [];
                    }
                    if (e.target.checked) {
                        globalFilters[columnName].push(e.target.value);
                    } else {
                        globalFilters[columnName] = globalFilters[columnName].filter(v => v !== e.target.value);
                    }
                    updateGlobalFilters();
                });

                const label = document.createElement('label');
                label.htmlFor = checkboxId;
                label.textContent = displayValue;
                label.className = 'text-gray-300 hover:text-white cursor-pointer';

                div.appendChild(input);
                div.appendChild(label);
                filterOptionsContainer.appendChild(div);
            });
        }
    }

    function updateFilterOptions(columnName, searchText) {
        populateFilterOptions(columnName, searchText);
    }

    function getActiveGlobalFilters() {
        return globalFilters;
    }


    // --- Interactivity ---
    function makeResizable(element, config) {
        const handle = element.querySelector('.resize-handle');
        let isResizing = false;

        handle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            isResizing = true;
            
            const startWidth = element.offsetWidth;
            const startHeight = element.offsetHeight;
            const startX = e.clientX;
            const startY = e.clientY;

            function doResize(e) {
                if (!isResizing) return;
                const newWidth = startWidth + (e.clientX - startX);
                const newHeight = startHeight + (e.clientY - startY);
                element.style.width = `${newWidth}px`;
                element.style.height = `${newHeight}px`;
            }

            function stopResize() {
                if (!isResizing) return;
                isResizing = false;
                window.removeEventListener('mousemove', doResize);
                window.removeEventListener('mouseup', stopResize);
                
                config.size.width = element.style.width;
                config.size.height = element.style.height;

                if (charts[config.id]) {
                    charts[config.id].resize();
                }
                renderDashboard();
            }

            window.addEventListener('mousemove', doResize);
            window.addEventListener('mouseup', stopResize);
        });
    }

    async function handleExport() {
        const { jsPDF } = window.jspdf;
        const grid = document.getElementById('dashboardGrid');
        const originalBg = document.body.style.backgroundColor;
        document.body.style.backgroundColor = 'var(--bg-color)'; // Ensure BG is set for canvas

        try {
            const canvas = await html2canvas(grid, {
                backgroundColor: getComputedStyle(document.body).getPropertyValue('--bg-color'),
                scale: 2 // Higher resolution
            });

            document.body.style.backgroundColor = originalBg;

            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF({
                orientation: 'landscape',
                unit: 'px',
                format: [canvas.width, canvas.height]
            });
            pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
            pdf.save('dashboard.pdf');
        } catch(e) {
            console.error('Export failed', e);
            showError("Could not export to PDF. Check console for details.");
        }
    }

    // --- Card Deletion and Editing ---
    function showConfirmationModal(cardId) {
        confirmDeleteButton.dataset.cardId = cardId;
        confirmationModal.classList.remove('hidden');
    }

    function deleteCard(cardId) {
        dashboardCards = dashboardCards.filter(card => card.id !== cardId);
        renderDashboard();
    }

    function openEditModal(cardId) {
        currentEditCardId = cardId;
        const cardConfig = dashboardCards.find(card => card.id === cardId);
        if (!cardConfig) return;

        // Populate modal fields with current config
        editTitleInput.value = cardConfig.custom.title;
        editColorInput.value = cardConfig.custom.color;
        editBarThicknessInput.value = cardConfig.custom.thickness;
        editDataLabelsCheckbox.checked = cardConfig.custom.dataLabels;
        editSortOrderSelect.value = cardConfig.custom.sortOrder;

        // Update chart type buttons visual state using data attribute
        chartTypeButtons.forEach(btn => {
            if (btn.dataset.type === cardConfig.chartType) {
                btn.dataset.selected = "true";
            } else {
                btn.dataset.selected = "false";
            }
        });

        editCardModal.classList.remove('hidden');
        setTimeout(() => editCardModal.classList.remove('opacity-0'), 10);
    }
    
    function onChartTypeButtonClick(e) {
        chartTypeButtons.forEach(btn => btn.dataset.selected = "false");
        e.currentTarget.dataset.selected = "true";
    }

    function handleEditSubmit() {
        if (!currentEditCardId) return;

        const cardIndex = dashboardCards.findIndex(card => card.id === currentEditCardId);
        if (cardIndex === -1) return;

        // Find selected chart type using the new data attribute
        const selectedTypeBtn = document.querySelector('.chart-type-btn[data-selected="true"]');
        const newChartType = selectedTypeBtn ? selectedTypeBtn.dataset.type : dashboardCards[cardIndex].chartType;

        // Update card config
        dashboardCards[cardIndex].custom.title = editTitleInput.value;
        dashboardCards[cardIndex].custom.color = editColorInput.value;
        dashboardCards[cardIndex].custom.thickness = editBarThicknessInput.value;
        dashboardCards[cardIndex].custom.dataLabels = editDataLabelsCheckbox.checked;
        dashboardCards[cardIndex].custom.sortOrder = editSortOrderSelect.value;
        dashboardCards[cardIndex].chartType = newChartType;

        // Re-render dashboard to show changes
        renderDashboard();
        closeEditModal.click();
    }


    // --- Utils ---
    function getIcon(type) {
        const icons = {
            bar: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>',
            line: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 16 12 14 20 10 4 8 12 2 12"/></svg>',
            pie: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>',
            table: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3zM21 9H3M21 15H3M12 3v18"/></svg>'
        };
        return icons[type];
    }

    function generateColors(numColors) {
        const colors = [];
        for (let i = 0; i < numColors; i++) {
            const hue = (i * (360 / numColors)) % 360;
            colors.push(`hsla(${hue}, 70%, 60%, 0.8)`);
        }
        return colors;
    }

</script>
</body>
</html>
