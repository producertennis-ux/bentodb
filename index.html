<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>BentoDB | Your Interactive Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/sql-wasm.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <!-- New Libraries for Spreadsheet Parsing -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-color: #1a1a1a;
            --card-bg: rgba(40, 40, 40, 0.6);
            --border-color: rgba(255, 255, 255, 0.1);
            --text-color: #f0f0f0;
            --text-muted-color: #a0a0a0;
            --accent-color: #3b82f6;
            --glass-blur: 16px;
        }
        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            background-image: radial-gradient(circle at 1px 1px, rgba(255,255,255,0.1) 1px, transparent 0);
            background-size: 20px 20px;
        }
        .glass-card {
            background-color: var(--card-bg);
            backdrop-filter: blur(var(--glass-blur));
            -webkit-backdrop-filter: blur(var(--glass-blur));
            border: 1px solid var(--border-color);
            transition: all 0.2s ease-in-out;
        }
        .bento-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 1.5rem;
        }
        /* Custom scrollbar for a better look */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: rgba(0,0,0,0.2);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb {
            background: rgba(255,255,255,0.2);
            border-radius: 10px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255,255,255,0.3);
        }
        .resize-handle {
            position: absolute;
            width: 16px;
            height: 16px;
            right: -4px;
            bottom: -4px;
            cursor: nwse-resize;
            background-image: radial-gradient(circle at 2px 2px, rgba(255,255,255,0.5) 1px, transparent 0);
            background-size: 8px 8px;
            opacity: 0.5;
            transition: opacity 0.2s ease-in-out;
        }
        .bento-item:hover .resize-handle {
            opacity: 1;
        }
        .loading-spinner {
            border: 4px solid var(--border-color);
            border-top: 4px solid var(--accent-color);
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* Styles for the new filter popover */
        .filter-popover {
            position: absolute;
            z-index: 50;
            top: 100%;
            left: 0;
            width: 300px;
            max-height: 400px;
            overflow-y: auto;
            transform-origin: top;
            animation: fade-in 0.2s ease-out;
            display: none;
        }
        @keyframes fade-in {
            from { opacity: 0; transform: scale(0.95) translateY(-10px); }
            to { opacity: 1; transform: scale(1) translateY(0); }
        }
        .filter-popover.active {
            display: block;
        }

    </style>
</head>
<body class="min-h-screen">

    <!-- Uploader View -->
    <div id="uploaderView" class="fixed inset-0 flex items-center justify-center p-4 z-50 transition-opacity duration-300">
        <div class="w-full max-w-md text-center">
            <div class="glass-card p-8 rounded-2xl shadow-2xl">
                <h1 class="text-3xl font-bold mb-2">BentoDB</h1>
                <p class="text-md text-gray-400 mb-6">Create beautiful, interactive dashboards from your data files.</p>
                <div id="dropZone" class="border-2 border-dashed border-gray-600 rounded-xl p-8 cursor-pointer hover:border-blue-500 hover:bg-gray-800/20 transition-all">
                    <!-- Updated accept attribute to include spreadsheet files -->
                    <input type="file" id="dbFile" accept=".sqlite,.db,.sqlite3,.csv,.xls,.xlsx" class="hidden">
                    <p class="text-gray-400">Drag & Drop your database or spreadsheet file here</p>
                    <p class="text-gray-500 text-sm my-2">or</p>
                    <button id="browseButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">Browse Files</button>
                </div>
                <div id="loadingIndicator" class="hidden mt-6 flex flex-col items-center">
                    <div class="loading-spinner"></div>
                    <p id="loadingText" class="mt-3 text-gray-400">Loading database...</p>
                </div>
                <p id="error-message" class="text-red-500 mt-4 text-sm hidden"></p>
            </div>
        </div>
    </div>

    <!-- Dashboard View -->
    <div id="dashboardView" class="hidden opacity-0 transition-opacity duration-500">
        <header class="sticky top-0 z-30 p-4 glass-card m-4 rounded-xl">
            <div class="flex flex-col md:flex-row justify-between items-center gap-4">
                <div class="flex items-center gap-3">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>
                    <h1 class="text-xl font-bold">Dashboard</h1>
                </div>
                <div id="globalFilters" class="flex flex-wrap gap-2 items-center">
                    <!-- Global filter buttons will be dynamically injected here -->
                    <span id="initialFilterMsg" class="text-sm text-gray-500">Global filters will appear here once you add cards.</span>
                </div>
                <div class="flex items-center gap-2">
                    <button id="updateDashboardButton" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                         <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12a9 9 0 0 1-9 9 9 9 0 0 1-9-9c0-1.03.17-2.02.48-2.93"/><path d="M12 21V12h9"/><path d="M18.8 8.8c.47-.84.7-1.78.7-2.82A9 9 0 0 0 12 3"/></svg>
                         Update Dashboard
                    </button>
                    <button id="exportPdf" class="bg-indigo-600 hover:bg-indigo-700 text-white font-semibold py-2 px-4 rounded-lg transition-colors flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                        Export PDF
                    </button>
                </div>
            </div>
        </header>

        <main id="dashboardGrid" class="p-4 md:p-8 bento-grid">
            <div id="addQueryCard" class="glass-card rounded-2xl flex items-center justify-center min-h-[200px] cursor-pointer border-2 border-dashed border-gray-600 hover:border-blue-500 hover:bg-gray-800/20 transition-all">
                <div class="text-center">
                    <div class="text-4xl text-gray-500">+</div>
                    <p class="mt-2 font-semibold">Draft Query</p>
                </div>
            </div>
        </main>
    </div>

    <!-- Query Builder Modal -->
    <div id="queryModal" class="fixed inset-0 bg-black bg-opacity-70 backdrop-blur-sm flex items-center justify-center p-4 z-40 hidden opacity-0 transition-opacity duration-300">
        <div class="glass-card rounded-2xl w-full max-w-2xl max-h-[90vh] flex flex-col">
            <div class="p-5 border-b border-[var(--border-color)] flex justify-between items-center">
                <h2 class="text-xl font-bold">Query Builder</h2>
                <button id="closeModal" class="text-gray-400 hover:text-white">&times;</button>
            </div>
            <div class="p-6 space-y-5 overflow-y-auto">
                <!-- Table Selection -->
                <div>
                    <label for="tableSelect" class="block text-sm font-medium text-gray-300 mb-1">1. Select Table</label>
                    <select id="tableSelect" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none"></select>
                </div>
                <!-- Summarize -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">2. Summarize (Aggregate)</label>
                    <div class="grid grid-cols-2 gap-4">
                        <select id="summarizeFunc" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <option value="COUNT">Count</option>
                            <option value="SUM">Sum</option>
                            <option value="AVG">Average</option>
                            <option value="MIN">Minimum</option>
                            <option value="MAX">Maximum</option>
                        </select>
                        <select id="summarizeColumn" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none" disabled>
                            <option>Select Column</option>
                        </select>
                    </div>
                </div>
                <!-- Group By -->
                <div>
                    <label class="block text-sm font-medium text-gray-300 mb-1">3. By (Group By)</label>
                    <div class="grid grid-cols-2 gap-4">
                        <select id="groupByColumn" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none">
                            <option>Select Column</option>
                        </select>
                        <select id="groupByDate" class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 focus:ring-2 focus:ring-blue-500 focus:outline-none hidden">
                            <option value="auto">Auto</option>
                            <option value="year">Year</option>
                            <option value="month">Month</option>
                            <option value="week">Week</option>
                            <option value="day">Day</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="p-5 border-t border-[var(--border-color)] flex justify-end items-center gap-4">
                <p id="modal-error" class="text-red-400 text-sm hidden"></p>
                <button id="submitQuery" class="bg-blue-600 hover:bg-blue-700 text-white font-semibold py-2 px-5 rounded-lg transition-colors">Create Card</button>
            </div>
        </div>
    </div>
    
    <!-- Global Filter Popover -->
    <div id="filterPopover" class="glass-card filter-popover p-4 rounded-xl shadow-lg" tabindex="-1">
      <div class="flex items-center justify-between border-b border-gray-600 pb-2 mb-2">
        <h3 id="popoverTitle" class="font-semibold">Filter Options</h3>
        <button id="closeFilterPopover" class="text-gray-400 hover:text-white">&times;</button>
      </div>
      <div class="flex flex-col gap-2">
        <input id="filterSearch" type="text" placeholder="Search..." class="w-full bg-gray-900/50 border border-gray-600 rounded-lg p-2 text-sm focus:ring-2 focus:ring-blue-500 focus:outline-none">
        <div id="filterOptionsContainer" class="max-h-64 overflow-y-auto space-y-1 pr-2">
          <!-- Checkbox options will be injected here -->
        </div>
      </div>
    </div>


<script>
    // --- Polyfill for crypto.randomUUID for non-secure contexts ---
    if (typeof crypto === 'undefined' || !crypto.randomUUID) {
        crypto.randomUUID = () => {
            return ([1e7] + -1e3 + -4e3 + -8e3 + -1e11).replace(/[018]/g, c =>
                (c ^ (crypto.getRandomValues(new Uint8Array(1))[0] & (15 >> (c / 4)))).toString(16)
            );
        };
    }

    // --- DOM Elements ---
    const uploaderView = document.getElementById('uploaderView');
    const dashboardView = document.getElementById('dashboardView');
    const dbFileInput = document.getElementById('dbFile');
    const dropZone = document.getElementById('dropZone');
    const browseButton = document.getElementById('browseButton');
    const loadingIndicator = document.getElementById('loadingIndicator');
    const loadingText = document.getElementById('loadingText');
    const errorMessage = document.getElementById('error-message');
    const addQueryCard = document.getElementById('addQueryCard');
    const queryModal = document.getElementById('queryModal');
    const closeModal = document.getElementById('closeModal');
    const tableSelect = document.getElementById('tableSelect');
    const summarizeFunc = document.getElementById('summarizeFunc');
    const summarizeColumn = document.getElementById('summarizeColumn');
    const groupByColumn = document.getElementById('groupByColumn');
    const groupByDate = document.getElementById('groupByDate');
    const submitQuery = document.getElementById('submitQuery');
    const dashboardGrid = document.getElementById('dashboardGrid');
    const globalFiltersContainer = document.getElementById('globalFilters');
    const exportPdfButton = document.getElementById('exportPdf');
    const updateDashboardButton = document.getElementById('updateDashboardButton');
    const modalError = document.getElementById('modal-error');
    const filterPopover = document.getElementById('filterPopover');
    const popoverTitle = document.getElementById('popoverTitle');
    const closeFilterPopover = document.getElementById('closeFilterPopover');
    const filterSearch = document.getElementById('filterSearch');
    const filterOptionsContainer = document.getElementById('filterOptionsContainer');


    // --- App State ---
    let db;
    let dbSchema = {};
    let dashboardCards = [];
    let charts = {}; // To store chart instances
    let globalFilters = {}; // Key: columnName, Value: Array of selected values

    // --- SQL.js Initialization ---
    async function initializeSqlJs() {
        try {
            const SQL = await initSqlJs({
                locateFile: file => `https://cdnjs.cloudflare.com/ajax/libs/sql.js/1.10.3/${file}`
            });
            return SQL;
        } catch (err) {
            console.error(err);
            showError("Failed to load SQL.js library. Please check your internet connection.");
        }
    }

    let sqlJsPromise = initializeSqlJs();

    // --- Event Listeners ---
    browseButton.addEventListener('click', () => dbFileInput.click());
    dbFileInput.addEventListener('change', handleFileSelect);
    dropZone.addEventListener('dragover', (e) => {
        e.preventDefault();
        dropZone.classList.add('border-blue-500', 'bg-gray-800/20');
    });
    dropZone.addEventListener('dragleave', () => {
        dropZone.classList.remove('border-blue-500', 'bg-gray-800/20');
    });
    dropZone.addEventListener('drop', handleFileDrop);
    addQueryCard.addEventListener('click', openQueryModal);
    closeModal.addEventListener('click', closeQueryModal);
    queryModal.addEventListener('click', (e) => {
        if (e.target === queryModal) closeQueryModal();
    });

    tableSelect.addEventListener('change', onTableSelectChange);
    summarizeFunc.addEventListener('change', onSummarizeFuncChange);
    groupByColumn.addEventListener('change', onGroupByColumnChange);
    submitQuery.addEventListener('click', handleQuerySubmit);
    exportPdfButton.addEventListener('click', handleExport);
    updateDashboardButton.addEventListener('click', renderDashboard);

    // Filter popover listeners
    closeFilterPopover.addEventListener('click', closeFilterPopoverFunc);
    filterSearch.addEventListener('input', (e) => updateFilterOptions(e.target.dataset.column, e.target.value));

    // Close popover when clicking outside
    document.addEventListener('click', (e) => {
        if (filterPopover.classList.contains('active') && !filterPopover.contains(e.target) && !e.target.closest('.filter-button')) {
            closeFilterPopoverFunc();
        }
    });


    // --- File Handling ---
    function handleFileDrop(e) {
        e.preventDefault();
        dropZone.classList.remove('border-blue-500', 'bg-gray-800/20');
        const files = e.dataTransfer.files;
        if (files.length) {
            dbFileInput.files = files;
            handleFileSelect({ target: { files } });
        }
    }

    async function handleFileSelect(event) {
        const file = event.target.files[0];
        if (!file) return;

        loadingIndicator.classList.remove('hidden');
        dropZone.classList.add('hidden');
        errorMessage.classList.add('hidden');
        
        const fileExtension = file.name.split('.').pop().toLowerCase();
        let fileBuffer;
        
        try {
            loadingText.textContent = "Reading file...";
            fileBuffer = await file.arrayBuffer();

            const SQL = await sqlJsPromise;
            db = new SQL.Database(); // Create a new in-memory DB
            
            if (['sqlite', 'db', 'sqlite3'].includes(fileExtension)) {
                loadingText.textContent = "Loading database...";
                db = new SQL.Database(new Uint8Array(fileBuffer));
            } else if (['csv', 'xls', 'xlsx'].includes(fileExtension)) {
                loadingText.textContent = "Parsing spreadsheet...";
                await loadSpreadsheet(file, fileBuffer);
            } else {
                throw new Error("Unsupported file type.");
            }
            
            await inspectDatabase();
            
            // Transition to dashboard
            uploaderView.classList.add('opacity-0');
            setTimeout(() => {
                uploaderView.classList.add('hidden');
                dashboardView.classList.remove('hidden');
                setTimeout(() => dashboardView.classList.remove('opacity-0'), 50);
            }, 300);

        } catch (err) {
            console.error("File loading error:", err);
            showError(`Could not read the file: ${err.message}.`);
            loadingIndicator.classList.add('hidden');
            dropZone.classList.remove('hidden');
        }
    }
    
    // Function to parse spreadsheet data and load it into SQLite
    async function loadSpreadsheet(file, buffer) {
        const fileExtension = file.name.split('.').pop().toLowerCase();
        let data = [];
        let tableHeader = [];
        
        if (fileExtension === 'csv') {
            await new Promise((resolve, reject) => {
                Papa.parse(file, {
                    header: true,
                    skipEmptyLines: true,
                    complete: (results) => {
                        data = results.data;
                        if (data.length > 0) {
                            tableHeader = Object.keys(data[0]);
                        }
                        resolve();
                    },
                    error: (error) => reject(error)
                });
            });
        } else if (['xls', 'xlsx'].includes(fileExtension)) {
            const workbook = XLSX.read(buffer, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            const sheet = workbook.Sheets[sheetName];
            data = XLSX.utils.sheet_to_json(sheet, { header: 1 });
            if (data.length > 0) {
                tableHeader = data[0];
                data = data.slice(1);
            }
        } else {
            throw new Error("Unsupported file type.");
        }

        if (data.length === 0) {
            throw new Error("The file is empty or could not be parsed.");
        }

        const tableName = sanitizeTableName(file.name);
        // Create table with TEXT columns by default
        const columns = tableHeader.map(c => `"${sanitizeColumnName(c)}" TEXT`);
        const placeholders = tableHeader.map(() => '?').join(', ');
        
        db.exec(`CREATE TABLE IF NOT EXISTS "${tableName}" (${columns.join(', ')});`);

        const insertStmt = db.prepare(`INSERT INTO "${tableName}" VALUES (${placeholders});`);
        db.run('BEGIN TRANSACTION;');
        try {
            data.forEach(row => {
                const values = Array.isArray(row) ? row : tableHeader.map(h => row[h]);
                insertStmt.run(values);
            });
            db.run('COMMIT;');
        } catch (e) {
            db.run('ROLLBACK;');
            throw new Error(`Failed to insert data: ${e.message}`);
        } finally {
            insertStmt.free();
        }
    }
    
    // Updated sanitization logic for file names
    function sanitizeTableName(name) {
        // Remove file extension
        const baseName = name.split('.').slice(0, -1).join('.');
        // Replace invalid characters with underscore
        let sanitized = baseName.replace(/[^a-zA-Z0-9_]/g, '_');
        // Ensure it doesn't start with a number, which can cause SQL errors
        if (sanitized.match(/^\d/)) {
            sanitized = 't_' + sanitized;
        }
        return sanitized;
    }

    // Updated sanitization logic for column names
    function sanitizeColumnName(name) {
        // Replace invalid characters with underscore
        let sanitized = name.replace(/[^a-zA-Z0-9_]/g, '_');
        // Replace multiple underscores with a single one
        sanitized = sanitized.replace(/_+/g, '_');
        // Ensure it doesn't start with a number
        if (sanitized.match(/^\d/)) {
            sanitized = 'col_' + sanitized;
        }
        return sanitized.toLowerCase();
    }
    
    function showError(message) {
        errorMessage.textContent = message;
        errorMessage.classList.remove('hidden');
    }
    
    // --- Database Schema Inspection ---
    async function inspectDatabase() {
        const tablesResult = db.exec("SELECT name FROM sqlite_master WHERE type='table' AND name NOT LIKE 'sqlite_%';");
        if (!tablesResult.length) return;

        const tableNames = tablesResult[0].values.map(v => v[0]);
        dbSchema.tables = tableNames;

        for (const tableName of tableNames) {
            // Re-inspect the schema, but this time, infer column types from the data
            const columnsResult = db.exec(`PRAGMA table_info("${tableName}");`);
            const columns = columnsResult[0].values.map(col => ({
                name: col[1],
                type: col[2].toUpperCase(),
                inferredType: 'TEXT' // Default to TEXT
            }));
            
            // Now, run a query to infer numeric types
            for (const col of columns) {
                const sampleQuery = `SELECT "${col.name}" FROM "${tableName}" WHERE "${col.name}" IS NOT NULL LIMIT 10;`;
                const sampleResult = runQuery(sampleQuery);
                const allNumeric = sampleResult.values.every(row => {
                    const value = row[0];
                    return !isNaN(parseFloat(value)) && isFinite(value);
                });
                if (allNumeric) {
                    col.inferredType = 'NUMERIC';
                }
            }

            dbSchema[tableName] = { columns };
        }
        populateTableSelect();
    }
    
    // --- Query Modal Logic ---
    function populateTableSelect() {
        tableSelect.innerHTML = '<option disabled selected>Select a table</option>';
        dbSchema.tables.forEach(name => {
            const option = document.createElement('option');
            option.value = name;
            option.textContent = name;
            tableSelect.appendChild(option);
        });
    }
    
    function populateSummarizeColumn(tableName) {
        const { columns } = dbSchema[tableName];
        // Now use the inferredType to filter for numeric columns
        const numericColumns = columns.filter(c => c.inferredType === 'NUMERIC');

        summarizeColumn.innerHTML = '<option disabled selected>Select Column</option>';
        if (summarizeFunc.value !== 'COUNT') {
            numericColumns.forEach(col => {
                const option = document.createElement('option');
                option.value = col.name;
                option.textContent = col.name;
                summarizeColumn.appendChild(option);
            });
        }
    }

    function onTableSelectChange() {
        const tableName = tableSelect.value;
        if (!tableName || !dbSchema[tableName]) return;

        const { columns } = dbSchema[tableName];
        
        populateSummarizeColumn(tableName);
        
        groupByColumn.innerHTML = '<option disabled selected>Select Column</option>';
        columns.forEach(col => {
            const option = document.createElement('option');
            option.value = col.name;
            // Use the original type from pragma for date checks
            option.dataset.type = col.type; 
            option.textContent = col.name;
            groupByColumn.appendChild(option);
        });
        
        onSummarizeFuncChange();
        onGroupByColumnChange();
    }
    
    function onSummarizeFuncChange() {
        const isCount = summarizeFunc.value === 'COUNT';
        summarizeColumn.disabled = isCount;
        
        const tableName = tableSelect.value;
        // Added a check to alert the user to select a table first
        if (!isCount && (!tableName || tableName.includes('Select'))) {
            modalError.textContent = 'Please select a table first to see numeric columns.';
            modalError.classList.remove('hidden');
            setTimeout(() => modalError.classList.add('hidden'), 3000);
            return;
        }

        if (isCount) {
            summarizeColumn.innerHTML = '<option>Not Applicable</option>';
        } else {
            const tableName = tableSelect.value;
            if (tableName && dbSchema[tableName]) {
                populateSummarizeColumn(tableName);
            }
        }
    }

    function onGroupByColumnChange() {
        const selectedOption = groupByColumn.options[groupByColumn.selectedIndex];
        if (!selectedOption) {
             groupByDate.classList.add('hidden');
             return;
        }
        const type = selectedOption.dataset.type;
        const isDateType = ['DATE', 'DATETIME', 'TIMESTAMP'].includes(type);
        groupByDate.classList.toggle('hidden', !isDateType);
    }
    
    function openQueryModal() {
        queryModal.classList.remove('hidden');
        setTimeout(() => queryModal.classList.remove('opacity-0'), 10);
    }

    function closeQueryModal() {
        queryModal.classList.add('opacity-0');
        setTimeout(() => {
            queryModal.classList.add('hidden');
            modalError.classList.add('hidden'); // Hide error on close
        }, 300);
    }

    // --- Query Execution & Card Creation ---
    async function handleQuerySubmit() {
        const table = tableSelect.value;
        const aggFunc = summarizeFunc.value;
        const aggColumn = summarizeColumn.value;
        const groupBy = groupByColumn.value;

        if (!table || table.includes('Select') ||
            !groupBy || groupBy.includes('Select') ||
            (aggFunc !== 'COUNT' && (!aggColumn || aggColumn.includes('Select'))))
        {
            modalError.textContent = 'Please fill out all fields correctly.';
            modalError.classList.remove('hidden');
            setTimeout(() => modalError.classList.add('hidden'), 3000);
            return;
        }

        const queryConfig = {
            id: crypto.randomUUID(),
            table: table,
            aggFunc: aggFunc,
            aggColumn: aggFunc === 'COUNT' ? '*' : aggColumn,
            groupBy: groupBy,
            groupByDateUnit: groupByDate.value,
            chartType: 'bar',
            custom: {
                title: `${aggFunc} of ${aggColumn || 'Rows'} by ${groupBy}`,
                color: '#3b82f6'
            },
            size: { width: 'auto', height: '400px' }
        };

        dashboardCards.push(queryConfig);
        renderDashboard();
        closeQueryModal();
    }

    function buildQuery(config, filters = {}) {
        let selectClause = '';
        let groupByClause = `GROUP BY T1."${config.groupBy}"`;
        let whereClauses = [];

        // Correctly handle COUNT(*) and other aggregates
        const aggColumnSelect = config.aggColumn === '*' ? '*' : `T1."${config.aggColumn}"`;

        const tableSchema = dbSchema[config.table];
        if (!tableSchema) return ''; // Should not happen
        const groupByColumnSchema = tableSchema.columns.find(c => c.name === config.groupBy);
        const groupByColType = groupByColumnSchema ? groupByColumnSchema.type : '';
        const isDateType = ['DATE', 'DATETIME', 'TIMESTAMP'].includes(groupByColType);

        if (isDateType && config.groupByDateUnit && config.groupByDateUnit !== 'auto') {
             let format;
             switch(config.groupByDateUnit) {
                 case 'year': format = '%Y'; break;
                 case 'month': format = '%Y-%m'; break;
                 case 'week': format = '%Y-%W'; break;
                 case 'day': format = '%Y-%m-%d'; break;
             }
             if (format) {
                 selectClause = `strftime('${format}', T1."${config.groupBy}") as "${config.groupBy}", ${config.aggFunc}(${aggColumnSelect}) as value`;
                 groupByClause = `GROUP BY 1`; // Group by the first column
             }
        }
        
        if (!selectClause) {
            selectClause = `T1."${config.groupBy}", ${config.aggFunc}(${aggColumnSelect}) as value`;
        }

        // Apply global filters
        for(const [key, values] of Object.entries(filters)) {
            if(values && values.length > 0) {
                const quotedValues = values.map(v => `'${v.replace(/'/g, "''")}'`).join(',');
                whereClauses.push(`T1."${key}" IN (${quotedValues})`);
            }
        }
        let whereClause = whereClauses.length > 0 ? `WHERE ${whereClauses.join(' AND ')}` : '';
        const orderByClause = `ORDER BY 2 DESC LIMIT 50`; // Order by the second column (value), limit for performance

        return `SELECT ${selectClause} FROM "${config.table}" AS T1 ${whereClause} ${groupByClause} ${orderByClause};`;
    }

    function runQuery(sql) {
        try {
            const results = db.exec(sql);
            if (results.length > 0) {
                return results[0]; // Returns {columns: [...], values: [...]}
            }
            return { columns: [], values: [] };
        } catch(e) {
            console.error("Query failed:", sql, e);
            return { error: e.message };
        }
    }

    // --- Dashboard Rendering ---
    function renderDashboard() {
        dashboardGrid.innerHTML = '';
        dashboardGrid.appendChild(addQueryCard);
        dashboardCards.forEach(cardConfig => createCard(cardConfig));
        updateGlobalFilters();
    }
    
    function createCard(config) {
        const cardEl = document.createElement('div');
        cardEl.className = 'bento-item glass-card rounded-2xl p-4 flex flex-col relative';
        cardEl.id = `card-${config.id}`;
        cardEl.style.height = config.size.height;
        // Handle responsive resizing properly
        if (config.size.width && config.size.width !== 'auto') {
            cardEl.style.width = config.size.width;
            if(parseInt(config.size.width, 10) > dashboardGrid.clientWidth * 0.9) {
                 cardEl.style.gridColumn = '1 / -1';
            }
        }


        const sql = buildQuery(config, globalFilters);
        const result = runQuery(sql);

        // Header
        const header = document.createElement('div');
        header.className = 'flex justify-between items-start mb-2';
        const title = document.createElement('h3');
        title.className = 'font-semibold text-base pr-2';
        title.textContent = config.custom.title;
        header.appendChild(title);

        // Controls
        const controls = document.createElement('div');
        controls.className = 'flex gap-1';
        ['bar', 'line', 'pie', 'table'].forEach(type => {
            const btn = document.createElement('button');
            btn.innerHTML = getIcon(type);
            btn.className = `p-1 rounded ${config.chartType === type ? 'bg-blue-600/50' : 'hover:bg-gray-700'}`;
            btn.onclick = () => {
                config.chartType = type;
                renderDashboard();
            };
            controls.appendChild(btn);
        });
        header.appendChild(controls);

        // Chart/Table container
        const contentContainer = document.createElement('div');
        contentContainer.className = 'flex-grow relative';

        if(result.error){
            contentContainer.innerHTML = `<div class="text-red-400 text-sm p-4">Error: ${result.error}</div>`
        } else if (config.chartType === 'table') {
            contentContainer.innerHTML = createTableHTML(result);
        } else {
            const canvas = document.createElement('canvas');
            contentContainer.appendChild(canvas);
            setTimeout(() => createChart(canvas, config, result.values), 0); // Render chart after element is in DOM
        }
        
        // Resize handle
        const resizeHandle = document.createElement('div');
        resizeHandle.className = 'resize-handle';
        
        cardEl.append(header, contentContainer, resizeHandle);
        dashboardGrid.insertBefore(cardEl, addQueryCard);

        makeResizable(cardEl, config);
    }
    
    function createChart(canvas, config, data) {
        const labels = data.map(row => row[0]);
        const values = data.map(row => row[1]);

        if (charts[config.id]) {
            charts[config.id].destroy();
        }

        charts[config.id] = new Chart(canvas, {
            type: config.chartType,
            data: {
                labels: labels,
                datasets: [{
                    label: config.aggFunc,
                    data: values,
                    backgroundColor: config.chartType === 'pie' ? generateColors(values.length) : config.custom.color,
                    borderColor: config.custom.color,
                    borderWidth: 1,
                    tension: 0.1
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: {
                        display: config.chartType === 'pie',
                        labels: { color: 'white' }
                    }
                },
                scales: {
                    x: { display: config.chartType !== 'pie', ticks: { color: 'white', autoSkip: true, maxTicksLimit: 10 } },
                    y: { display: config.chartType !== 'pie', ticks: { color: 'white' } }
                }
            }
        });
    }

    function createTableHTML(result) {
        const { columns, values } = result;
        if (!values || values.length === 0) return '<p class="text-gray-500 text-center p-4">No data to display.</p>';

        let tableHTML = '<div class="overflow-auto h-full"><table class="w-full text-sm text-left"><thead><tr class="border-b border-gray-700">';
        columns.forEach(h => tableHTML += `<th class="p-2">${h}</th>`);
        tableHTML += '</tr></thead><tbody>';
        values.forEach(row => {
            tableHTML += '<tr class="border-b border-gray-800">';
            row.forEach(cell => tableHTML += `<td class="p-2">${cell === null ? 'NULL' : cell}</td>`);
            tableHTML += '</tr>';
        });
        tableHTML += '</tbody></table></div>';
        return tableHTML;
    }

    // --- Global Filters ---
    function updateGlobalFilters() {
        const activeColumns = new Map();
        dashboardCards.forEach(card => {
            dbSchema[card.table].columns.forEach(col => {
                if(!activeColumns.has(col.name)) {
                     activeColumns.set(col.name, col.type);
                }
            });
        });

        const initialFilterMsg = document.getElementById('initialFilterMsg');
        if (initialFilterMsg) {
            initialFilterMsg.classList.toggle('hidden', activeColumns.size > 0);
        }
        globalFiltersContainer.innerHTML = '';
        activeColumns.forEach((colType, colName) => {
            const filterId = `global-filter-${colName.replace(/[^a-zA-Z0-9_]/g, '_')}`;
            
            const btn = document.createElement('button');
            btn.className = `filter-button relative bg-gray-900/50 hover:bg-gray-800/50 text-white font-semibold py-2 px-4 rounded-lg transition-colors text-sm`;
            btn.textContent = colName;
            btn.dataset.column = colName;
            
            // Add a counter to the button if filters are active
            if (globalFilters[colName] && globalFilters[colName].length > 0) {
                const countSpan = document.createElement('span');
                countSpan.className = 'ml-2 text-xs font-bold text-white bg-blue-600 rounded-full px-2 py-1';
                countSpan.textContent = globalFilters[colName].length;
                btn.appendChild(countSpan);
            }

            btn.addEventListener('click', (e) => openFilterPopover(e, colName));
            globalFiltersContainer.appendChild(btn);
        });
    }

    function openFilterPopover(e, columnName) {
        const rect = e.target.getBoundingClientRect();
        filterPopover.style.top = `${rect.bottom + window.scrollY + 8}px`;
        filterPopover.style.left = `${rect.left + window.scrollX}px`;
        popoverTitle.textContent = `Filter by ${columnName}`;
        filterSearch.dataset.column = columnName;
        filterSearch.value = '';
        filterPopover.classList.add('active');
        populateFilterOptions(columnName);
    }
    
    function closeFilterPopoverFunc() {
        filterPopover.classList.remove('active');
    }

    function populateFilterOptions(columnName, searchText = '') {
        filterOptionsContainer.innerHTML = '<p class="text-center text-gray-500">Loading...</p>';
        const tableNameForFilter = dbSchema.tables.find(t => dbSchema[t].columns.some(c => c.name === columnName));
        if (!tableNameForFilter) {
            filterOptionsContainer.innerHTML = '<p class="text-center text-gray-500">No data found.</p>';
            return;
        }

        const distinctValuesQuery = `SELECT DISTINCT "${columnName}" FROM "${tableNameForFilter}" WHERE "${columnName}" IS NOT NULL ORDER BY "${columnName}" ASC LIMIT 1000;`;
        const results = runQuery(distinctValuesQuery);
        
        filterOptionsContainer.innerHTML = '';
        const selectedValues = globalFilters[columnName] || [];
        
        if (results && Array.isArray(results.values)) {
            const filteredValues = results.values.filter(row => 
                String(row[0]).toLowerCase().includes(searchText.toLowerCase())
            );

            filteredValues.forEach(row => {
                const value = row[0];
                const checkboxId = `${columnName}-${value.replace(/[^a-zA-Z0-9_]/g, '_')}`;
                
                const div = document.createElement('div');
                div.className = 'flex items-center space-x-2';
                const input = document.createElement('input');
                input.type = 'checkbox';
                input.id = checkboxId;
                input.value = value;
                input.checked = selectedValues.includes(value);
                input.className = 'w-4 h-4 text-blue-600 bg-gray-700 border-gray-600 rounded focus:ring-blue-500';
                input.addEventListener('change', (e) => {
                    if (!globalFilters[columnName]) {
                        globalFilters[columnName] = [];
                    }
                    if (e.target.checked) {
                        globalFilters[columnName].push(e.target.value);
                    } else {
                        globalFilters[columnName] = globalFilters[columnName].filter(v => v !== e.target.value);
                    }
                    updateGlobalFilters();
                });

                const label = document.createElement('label');
                label.htmlFor = checkboxId;
                label.textContent = value;
                label.className = 'text-gray-300 hover:text-white cursor-pointer';

                div.appendChild(input);
                div.appendChild(label);
                filterOptionsContainer.appendChild(div);
            });
        }
    }

    function updateFilterOptions(columnName, searchText) {
        populateFilterOptions(columnName, searchText);
    }

    function getActiveGlobalFilters() {
        return globalFilters;
    }


    // --- Interactivity ---
    function makeResizable(element, config) {
        const handle = element.querySelector('.resize-handle');
        let isResizing = false;

        handle.addEventListener('mousedown', function(e) {
            e.preventDefault();
            e.stopPropagation();
            isResizing = true;
            
            const startWidth = element.offsetWidth;
            const startHeight = element.offsetHeight;
            const startX = e.clientX;
            const startY = e.clientY;

            function doResize(e) {
                if (!isResizing) return;
                const newWidth = startWidth + (e.clientX - startX);
                const newHeight = startHeight + (e.clientY - startY);
                element.style.width = `${newWidth}px`;
                element.style.height = `${newHeight}px`;
            }

            function stopResize() {
                if (!isResizing) return;
                isResizing = false;
                window.removeEventListener('mousemove', doResize);
                window.removeEventListener('mouseup', stopResize);
                
                config.size.width = element.style.width;
                config.size.height = element.style.height;

                if (charts[config.id]) {
                    charts[config.id].resize();
                }
                renderDashboard();
            }

            window.addEventListener('mousemove', doResize);
            window.addEventListener('mouseup', stopResize);
        });
    }

    async function handleExport() {
        const { jsPDF } = window.jspdf;
        const grid = document.getElementById('dashboardGrid');
        const originalBg = document.body.style.backgroundColor;
        document.body.style.backgroundColor = 'var(--bg-color)'; // Ensure BG is set for canvas

        try {
            const canvas = await html2canvas(grid, {
                backgroundColor: getComputedStyle(document.body).getPropertyValue('--bg-color'),
                scale: 2 // Higher resolution
            });

            document.body.style.backgroundColor = originalBg;

            const imgData = canvas.toDataURL('image/png');
            const pdf = new jsPDF({
                orientation: 'landscape',
                unit: 'px',
                format: [canvas.width, canvas.height]
            });
            pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
            pdf.save('dashboard.pdf');
        } catch(e) {
            console.error('Export failed', e);
            showError("Could not export to PDF. Check console for details.");
        }
    }


    // --- Utils ---
    function getIcon(type) {
        const icons = {
            bar: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><line x1="12" y1="20" x2="12" y2="10"/><line x1="18" y1="20" x2="18" y2="4"/><line x1="6" y1="20" x2="6" y2="16"/></svg>',
            line: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="22 12 16 12 14 20 10 4 8 12 2 12"/></svg>',
            pie: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"/><path d="M22 12A10 10 0 0 0 12 2v10z"/></svg>',
            table: '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3h18v18H3zM21 9H3M21 15H3M12 3v18"/></svg>'
        };
        return icons[type];
    }

    function generateColors(numColors) {
        const colors = [];
        for (let i = 0; i < numColors; i++) {
            const hue = (i * (360 / numColors)) % 360;
            colors.push(`hsla(${hue}, 70%, 60%, 0.8)`);
        }
        return colors;
    }

</script>
</body>
</html>
